# AltNet
An Old Alternative, tried again
<hr>
</br></br>
&nbsp; &nbsp; &nbsp; To network within a hash is to plan or dynamically prepare ahead. Hash-based Netowrking isn't a new concept and has been in many cases reprooven as a possible ventrue for decentralizing or seperating the signature from the entity controller.</br>
&nbsp; &nbsp; &nbsp; Hash networking in the past was slow and incapable of handling rapid growth but through services like Bitcoin, some of the slowest hashed-networks are now some of the most relieable data-storage networks (even though it's barely being used as data-storage for external data). Theoretically it should be possible to encode a network within a hash then use other hashes to then interact with that hashed-network. So in other words, you should be able to place a hash within a network like bitcoin and then when opening that hash we should be able to have a method of interacting. There after, everything should work as intended. Perhaps you could say there needs to be unpacking time for the hash can have any number of hashes within it. Just from this, it should be easy to see why old hashnetworks failed. Infinately possible hashes makes more work to unpack, but much has happened since 2009.</br></br>
&nbsp; &nbsp; &nbsp; Bitcoin prooved hashnetworks can work. IPFS prooved hashnetworks can interact. IPNS prooved hashnetworks can direct. Itty-Bitty-Site prooved hashnetworks can be self-served & portable. PvtPpr prooved hashnetworks can self-direct data to-and-from any network to any network with or without being apart of the hashnetwork.
</br></br>
&nbsp; &nbsp; &nbsp; To self host your data, is to be upholding your end of the internet. If we consider the internet any-and-all interconnected services working as one greater entity, then hashnetworks are the portable bays of the internet, or at least they can be. Many people consider the internet anything they can bring up on a browser & in this state, it's not completely wrong but a browser is a limited technology in retrospect that has tons of extra features to make more be able to appear within it so it can be altered by a user to see more netowrks or more networks can just work within the link-provisions.</br>
&nbsp; &nbsp; &nbsp; Itty-Bitty-Site took the basic link-provisions and figured out how to work around basic storage by hashing the data and stuffing that hash within the link. This does two major things. First, it seperates data-storage from the server or harddrive. Second, it seperates servers from workload from permissions.</br>
&nbsp; &nbsp; &nbsp; Seperating data-storage from the server or drive may seem like an overshoot because sure something is storing the textfile of the link but no drive or server is storing the data within the Itty-Bitty-Site Hashlink but simply the text of the link containing the hash. This means that data can actually direct the browser while the node-server is only decoupling the hash from it's compression. This is important because this coupling can be modified and thus making some publicly avaliable nodes unable to decouple the hash from it's compression but just knowing the difference (key) or having the decoding script will still open the modified hashlink. If the server was important or in this case if the node was important then no other node could decouple the hash. But because Itty-Bitty-Site seperates front-link from slug, we can modify the front end and compression without messing up the data inside so no part of any part is relient on any part except for itself & the decoding key.</br>
&nbsp; &nbsp; &nbsp; Seperating servers from workload was first introduced in the late 90s and early 2000s but nowadays there are tons of ways to perform this task. However, Itty-Bitty-Site takes this a step fruther by having essintially a ring-layering system within each hashlink, allowing the seperation of permissions. So the node has ring0 capabilities like displaying and serving ads independently form the data or client ads. The data has ring1 which can dip into ring0, it is not easy unless the node allows for the extra execution of ring0. So even in how Itty-Bitty-Site is designed, the node can be independently different from others. For example, there was a full JavaScript based node for Itty-Bitty-Site known as Itty-Bitty-App which gave data ring0 access but didn't give up any persmissions nor give any extra allowances, only allowed for CSS for ring1. Custom-Sheet-Styling is a type of permission for web-based systems because entire sites can be made form CSS just like entire sites can be made form HTML or JS. This node was successfull enough for Itty-Bitty-Site to gain controll of the node for a more unified experience. This did proove, that the server is similar to Bitcoin Nodes and Miners. The configuration, adaption, & execution is 100% up to the user just as long as it works with the rest.
</br></br>
&nbsp; &nbsp; &nbsp; At this point you are potentially seeing the problem, size and link length.  There isn't much you can place in a hashlink that can be easily distributed online as-of-right-now. For example some of the places online that allow for large link usage are link-shorteners.</br>
&nbsp; &nbsp; &nbsp; The biggest publicly avaliable link-shortner will allow for up to 16,000 bytes of data, 16 kilobits and that's it. However, what all can you place within 16KB? I placed a generator within 16KB, a generator that would allow anyone to form a hashlink to the Itty-Bitty-Site standards so any Itty-Bitty-Node could run them. At first I did a simple, "paste a link to see the image" generator that slowly taught me how to use Base64 media hashes as native media. That slowly opened up to PvtPpr generators that then allowed anyone whom can open the geneator to build article pages, blogs, and similar top-down text-driven webpages. Slowly more generators was built, each doing something different from individual pages to newspapers to Non-Fungible Tokens to threading through block media for alternative entry points to-and-from network hashes, links & hashlinks. Eventually there became an alternative internet option. Dubbed "NaNo Networks" by an anonymous entity, these small little networks of generally different designs were starting to appear even outside PvtPpr & Itty-Bitty-Sites. PvtPpr took the blockchain idea and forced it inside the hashnet idea, so every PvtPpr generator also builds a blockchain type database within the hash. A data-determined pointer to the previous data-block. This does return to the problem we had before with hashnetworks thou.</br>
&nbsp; &nbsp; &nbsp; Bitcoin just like another similar network before it, they seperated each hash from each other but instead used internal pointers to point to the previous data-block. This is similar to how your computer talks to internal parts nowadays like registered network addressing. This does allow for some amount of scaling and through the practice of "large block" chains, the bigger the block, the more difficult it may be to read, open & verify. There are tons of ways to address this problem, which the best is segmented hashing or naturally broken [into pieces] hashes. Now, looking back at what I did. I simply looped outside-in & inside-out again thusly allowing internal networking within a single hash that can talk & communicate externally on it's, technical, own.</br>
&nbsp; &nbsp; &nbsp; Now Itty-Bitty-Site (IB) has alternatives to compression some of which allows for even more compression then before. Unfortunatly for myself, I am not able to figure any of the new compressions out. Honestly, most of it just sounds like off-shooting data for token swapping that makes IB v2 internet relient instead of how IB v1 is an intranet on its own. I could very easily be wrong on this but because I can't seem to get IB v2 working for myeself offline, I started to use IPFS & IPNS for extra help. At this point, I think IPFS & IPNS still isn't capable of handling temporary status figures like bitcoin can. For example, the PvtPpr IPNS & IPFS node had an error after the Helia update and has never been able to be recovered (although a new node is up running the same database), some of the original pointers don't point to the data in it's current location within it's own network. So IPNS won't direct to me because I"m a new entity or something and the original isn't found to verify or something, I'm not entirely sure. But from the problems of modern IPFS/IPNS & IB, I began a quest to a different option. A JavaScripted option.</br>
&nbsp; &nbsp; &nbsp; If you go through my repo (<a href="https://github.com/DigiMancer3D?tab=repositories" ref="noreferer noopener" target="_blank">DigiMancer3D</a>), you'll see some unusal builds like: <a href="https://github.com/DigiMancer3D/HashKey-Cutter" ref="noreferer noopener" target="_blank">HashKey-Cutter</a>, <a href="https://github.com/DigiMancer3D/B64-Image-Compression" ref="noreferer noopener" target="_blank">B64-Image-Compression</a>,<a href="https://github.com/DigiMancer3D/HashTeleporter" ref="noreferer noopener" target="_blank">HashTeleporter</a>. I was specifically trying to find a method in JavaScript to remove data and be able to later replace that data without storing anything outside the token placed in the removal of data. I did also want to try to remove data without notice but that quickly died as I wanted to just get better compressions with less. I then tried various things and came up with Wave-Data API for <a href="https://github.com/DigiMancer3D/iCS" ref="noreferer noopener" target="_blank">iCS</a>, an interactive Character Sheet for playing table-top & general RPGs. This was to help with the problems coming from D&D wanting to change their license agreement in a negative way. Wave-Data API allows anything on HTML/JS to be plug-and-play capable without lossing imporant data. This allows for seperation of individual units on a webpage or webapp from that webpage or webapp & it's controller/builder/running entity/foundation/host/provider/machine.</br>
&nbsp; &nbsp; &nbsp; Wave-Data API is designed where the data stored directs & informs the end system. For example, if you run iCS you can click on a button on the bottom of the page to get a hash that when inserted into iCS throuogh it's input system, it will give you an item. This hash is one of a few to mix up the possible outcome of your item but there is a place to get a "Tutorial item" which then is a basic tutorial of the system for exporting and importing. The hash has upfront identifiers like ";," or ".,." that will be used to have different sections within the hash, natural break points that ID what's next. These IDs are set in two: Meta & Data. Meta ID means, what's next explains the data thereafter. Data ID means, this is the data with last said Meta. Not all Data needs a Meta thou. So if your system is private and you don't disclose Meta IDs in your wave data, you simply have to know what to look for. In some cases with iCS Wave-Data Hashed-APIs, there will be system movement scripts as data. Their Meta ID tells the system what button to press before inserting the Data but this only happens in very specific situtations like placing the generated item in it's proper spot. For example you wouldn't want a weapon to show up in the armor area of your character, in other words: can't use a hammer as a arm guard and expect things to work the same. So, this does even allow for interactive Hashed-APIs, which sounds scary but since everything is CRC reversable, we can check to see what the script is ahead of time. If we know enough info about the webapp using this API, we could alter the script and even change names of items, etc etc etc.</br>
&nbsp; &nbsp; &nbsp; Being able to seperate web objects like this use to be a very common thing but now we could do things like build an ad spot with a proper payement system outside from the delievery network and for as long as the user is online, the ad should work completely as if it was original to that page even if the ad was injected using Wava-Data H-APIs even going to the point that the original ad-payee should still get paid accordingly as long as the ad-payor allows for embeding ad payments. This didn't seem to be helpful but it did allow anything on a webpage or webapp to be reduced down to an API now, which could reduce space in the hash. The idea here is, we could build a webpage that is dynamic but rigid enough to accept H-APIs to then build that webpage, webapp or even web-service only based on raw-data & it's Meta IDs but inline to the system that uses it. This is now the first step into dynamic compression without offshooting data, instead we are offshooting the un-important webcode to the opening system or web-de-complier-application.</br></br>
&nbsp; &nbsp; &nbsp; Having a method to arrange the data of a web-object to-and-fro the web-frame does mean if we can compress this H-API, we can make our web-systems even smaller while allowing for potentially more complicated native-web-features. Compression was next up. First I didn't even mean to go this route. I started attempting at building a new method of making this "Hashed-API" and wanted it to be well, a real hash and not just a Base64 Data-Blob. I want the end output to be a Base64 Data-Blob so we can hide in plain sight but also so the data within that Base64 Data-Blob will be treated like a Media Hash, allowing us to mix and match the output we'd like to have. So instead of having to pre-define a video output or a text output, the output wouldn't really matter cause the web browser would be expecting webworkers to assist. Well, that's exactly what we have, IB v1 webworker to be specific. Now we can setup the browser to expect any output in a manner that will allow us to launch almost anything from the server window that could even get us device ring0 access, theoretically at least.
